# СТРЕЛОЧНЫЕ ФУНКЦИИ
```js
(argument) => console.log(argument);
```
> Ключевые особенности: короткий синтаксис и привязка к глобальному `this`

Прочие особенности:
1. стрелка это оператор (название стрелочная функция)
2. стрелка должна идти сразу после параметров - ошибка вылетит даже если между ними поставить абзац.
3. стрелочные функции лексически привязаны к глобальному `this`, поэтому методы `bind`, `call` и `apply` не влияют на значение `this`
4. стрелочные функции не могут быть использованы как конструктор и вызовут ошибку при использовании с `new`
5. стрелочные функции не могут быть использованы как генераторы

Круглые скобки не обязательны для единственного параметра
```js
let func1 = a => a * 2;
console.log(func1(5)); // Output: 10
```

Возвращая литерал объекта нужно обернуть его в круглые скобки, иначе вернется `undefined`
```js
let func2 = () => ({key: "value"});
console.log(func2()); // Output: Object {key: "value"}
```

Если тело функции записано в краткой форме, результат возвращается неявно
```js
let func3 = () => 42;
console.log(func3()); // Output: 42
```

Если тело функции записано в блочной форме - результат необходимо вернуть явно, иначе вернется undefined
```js
let func4 = () => {
    return 42
};
console.log(func4()); // Output: 42
```
# SET
`Set` это структура данных, которая хранит уникальные значения
Создается с помощью конструктора
Конструктор принимает перебираемый объект, разбирает его на составные части и добавляет уникальные в `Set`
```js
let set = new Set([1, 2, 3, 2, 1]);
console.log(set); // Output: Set {0: 1, 1: 2, 2: 3}
```

Нельзя обращаться к элементам `set` по порядковому номеру, это вернет `undefined`
```js
console.log(set[1]); // Output: undefined
```

Размер сета можно увидеть через метод `size`
```js
console.log(set.size); // Output: 3
```

Метод `has` показывает есть ли значение в сете
```js
console.log(set.has(2)); // Output: true
```

Метод `add` позволяет добавить значение
```js
set.add(5);
console.log(set);
```

Метод `delete` позволяет удалить значение
```js
set.delete(5);
console.log(set);
```

Метод `clear` позволяет очистить `set`
```js
set.clear();
console.log(set);
```

# MAP
`Map` - это структура данных, которая хранит данные в парах ключ-значение

Ключевые особенности:
1. является итерируемым объектом
2. ключи в `Map` упорядочены, - во время итерации `Map`, ключи возвращаются в порядке вставки
3. ключом может быть любое значение

Создается конструктором
```js
let map = new Map();
```

Метод `add` позволяет добавить значение
```js
map.add(`key`, `value`);
console.log(map); // Output: Map {key: "value"}
```

Размер сета можно увидеть через метод `size`
```js
console.log(map.size); // Output: 1
```

# СИМВОЛЫ
Символ (`symbol`) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Ключевые особенности:
1. Каждый символ уникален, его значение которого не равно любому другому объекту.
2. Символы игнорируются циклом `for…in`
3. Метод `Symbol()` нельзя использовать с ключевым словом `new`.

Символы имеют два основных варианта использования:
1. «Скрытые» свойства объектов. К этим свойствам нельзя случайно обратиться и перезаписать их из других частей программы.
2. Существует множество «системных» символов, использующихся внутри самого JavaScript. Все они перечислены
   в спецификации языка в таблице "Well-known symbols". Они используются для настройки различных аспектов поведения объектов.

Чтобы создать символ нужно вызвать метод `Symbol()`
```js
let uniqueID = Symbol();
```

При создании символу можно дать описание (также называемое имя). Это имя используется в основном для отладки кода:
```js
let id = Symbol("symbol description");
```

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
### Глобальные символы (Well-known symbols)
Глобальные символы доступны во всех частях вашей программы. Они хранятся в глобальном реестре символов.
Для чтения (или, при отсутствии, создания) символа из реестра используется метод `Symbol.for(key)`.
Он проверяет глобальный реестр, и, если в нём есть символ с именем `key`, то возвращает его, иначе создаёт новый символ `Symbol(key)` и записывает его в реестр под ключом `key`.
*/

# ИТЕРАТОРЫ
Итерируемый объект - это объект содержание которого можно перебрать по 1 элементу (один за другим).
Итерируемые объекты: `string`, `array`, `set`, `map`...

Итерируемый объект отличается от неитерируемого тем, что у него есть метод который возвращает объект.
Для доступа к этому объекту используется специальный символ - итератор. Объект который возвращает этот символ называется итератор.
У итератора есть 1 метод - `next`, который возвращает объект с двумя свойствами - `done` и `value`.
`done` показывает есть ли еще элементы в последовательности, а value` соержит значение.