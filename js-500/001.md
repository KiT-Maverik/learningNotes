### Жизненный цикл памяти  
Когда выполняется объявление переменной или создается функция, то память проходит следующий цикл.

* **Allocate** — выделение памяти, что делает движок. Он выделяет память, которая требуется для созданного объекта.
* **Use** — использование памяти. За этот момент отвечает разработчик, прописывая в коде чтение и запись в память.
* **Release** — освобождение памяти. Здесь снова наступает «зона ответственности» JavaScript. После того, как резерв высвобожден, память можно использовать и для других целей.

> «Объекты» в контексте управления памятью подразумевают не только объекты JS, но также функции и области действия.

### Где хранятся данные?
* Cтеке (stack) памяти
* Куче (heap).

Что первое, что второе — название структур данных, которые используются движком для разных целей.

#### Стек (stack)
Стек — это статическое выделение памяти.  
Это структура данных, которая используется для хранения статических данных, их размер всегда известен во время компиляции. В JS сюда включили примитивные значения, например string, number, boolean, undefined и null, а также ссылки на функции и объекты.

Движок «понимает», что размер данных не меняется, поэтому выделяет фиксированный объем памяти для каждого из значений. Процесс выделения памяти до исполнения называется статическим выделением памяти (static memory allocation).

#### Куча (heap)
Куча (heap) — динамическое выделение памяти.
Используется она для хранения объектов и функций.
Но в отличие от стека движок не может «знать», какой объем памяти необходим для того либо иного объекта, поэтому память выделяется по мере необходимости. И этот способ выделения памяти называется «динамическим» (dynamic memory allocation).
В такой ситуации объект в куче похож на здание, а вот ссылка — это его адрес.

ссилочні типи даних зберігаються  в кучі.
Если значение не является примитивным, в стеке содержится ссылка на объект из кучи.
JS сохраняет объекты и функции в куче. А вот примитивные значения и ссылки — в стеке.

#### Garbage Collector
Движок JavaScript отвечает не только за выделение памяти, но и за освобождение. Память системе возвращает сборщик мусора (garbage collector).

И как только движок «видит», что в переменной или функции уже нет необходимости, выполняется освобождение памяти.

Це відбувається за допомогою різних алгоритмів.

> js однопоточен, поэтому все процессы заблокируются на время работы garbage collector’a

##### Алгоритм 1: підрахунок посилань.
Он убирает те объекты, на которые не указывает более ни одна ссылка.  
Недостаток алгоритма в том, что он не способен учитывать циклические ссылки. Они возникают тогда, когда один или более объектов ссылаются друга на друга, оказываясь вне зоны досягаемости с точки зрения кода.

##### Алгоритм 2: Алгоритм міток (mark and sweep)
Этот алгоритм не считает ссылки, а определяет, можно ли получить доступ к разным объектам посредством корневого объекта.
С 2012 года абсолютно все браузеры оснащаются сборщиками мусора, которые работают именно по методу mark and sweep.

недостатки: Использование большого объема памяти

Из-за того, что алгоритмы не умеют определять, когда именно память становится ненужной, приложения на JavaScript могут использовать больший объем памяти, чем нужно. И лишь сборщик может решить, освобождать или нет выделенную память.

### Производительность

Память не очищается каждый новый момент времени. Освобождение выполняется с определенной периодичностью. Но разработчики не могут знать, когда именно запускаются эти процессы.

Поэтому в некоторых случаях сборка мусора может негативно отражаться на производительности, поскольку алгоритму для работы нужны определенные ресурсы. Правда, ситуация редко становится прямо совсем уж неуправляемой. Чаще всего последствия этого микроскопические.

### Утечки памяти

В разработке утечка памяти — одно из самых неприятных явлений. Но если знать все самые распространенные виды утечек, то обойти проблему можно без особого труда.

##### Глобальные переменные

Утечки памяти чаще всего случаются из-за хранения данных в глобальных переменных.

В браузере, если ошибиться и использовать var вместо const или let, движок присоединит переменную к объекту window. Аналогичным образом он выполнит операцию с функциями, определенными словом function.

Глобальные переменные часто объявляются намеренно, это не всегда ошибка. НО в любом случае нельзя забывать об освобождении памяти после того, как в данных уже нет нужды. Для того нужно присвоить глобальной переменной null.

##### Забытые таймеры
Проблема в том, что объекты, на которые есть референс в интервале, не уничтожаются до тех пор, пока не выполняется очистка интервала. Поэтому нужно своевременно прописывать:
clearInterval(intervalId);

##### Забытый коллбек
Проблема может возникнуть в том случае, если к кнопке привязать обработчик onClick, а саму кнопку удалить после — например, она перестала быть нужной.

##### Забытые DOM-элементы в переменных
Все это похоже на предыдущий случай. Ошибка возникает в том случае, когда элементы DOM хранятся в переменной.













